package cn.bjjoy.bms.setting.service.impl;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.atomic.AtomicInteger;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import com.google.common.collect.Lists;import cn.bjjoy.bms.setting.dao.BaseDao;import cn.bjjoy.bms.setting.dto.AnalysisDto;import cn.bjjoy.bms.setting.dto.CurrentEquipData;import cn.bjjoy.bms.setting.exception.ServiceException;import cn.bjjoy.bms.setting.persist.mapper.EquipdataDao;import cn.bjjoy.bms.setting.persist.model.Equipdata;import cn.bjjoy.bms.setting.poi.ExportEquipData;import cn.bjjoy.bms.setting.service.EquipdataService;import cn.bjjoy.bms.util.DataUtils;import cn.bjjoy.bms.util.DateUtils;import cn.bjjoy.bms.util.OrgUtils;import cn.bjjoy.bms.util.SpringSocketUtil;/** * 类描述   : * 创建人	：system * 创建时间 ：2018-09-13 23:02:18 * * @version 1.0 */@SuppressWarnings("rawtypes")@Service@Transactionalpublic class EquipdataServiceImpl extends BaseServiceImpl<Equipdata> implements EquipdataService {    Logger logger = LoggerFactory.getLogger(EquipdataServiceImpl.class);    private AtomicInteger startIndex = new AtomicInteger();    @Autowired    private EquipdataDao equipdataDao;    @Override    public BaseDao<Equipdata> getBaseDao() {        return equipdataDao;    }    public long getCurrentAccount(Map map) {        return equipdataDao.getNewestDataCount(map);    }    @Override    public List<Map<String, Object>> queryOne(Map map) {        return equipdataDao.getNewestData(map);    }    @Override    public long getHistoryAccountNoPage(Map map) {        if (map.containsKey("rows")) {            map.remove("rows");        }        if (map.containsKey("page")) {            map.remove("page");        }        return Long.valueOf(String.valueOf(equipdataDao.getHistorySearch(map).size()));    }    @Override    public List<Map<String, Object>> getHistoryNoPage(Map map) {        return equipdataDao.getDataNoPage(map);    }    public List<AnalysisDto> analysisesDto(Map map) {        List<Map<String, Object>> mapAnalysis = equipdataDao.commonAnalysis(map);        return DataUtils.getDataArray(mapAnalysis, AnalysisDto.class);    }    @Override    public List<CurrentEquipData> setWifi(List<CurrentEquipData> equipList, Map map) {        List<CurrentEquipData> result = new ArrayList<CurrentEquipData>();        try {            Integer page = 0;            if (map != null && map.containsKey("page")) {                page = (Integer) map.get("page");                startIndex.set(page);            }            for (CurrentEquipData eqData : equipList) {                eqData.setSeq(startIndex.incrementAndGet());                String waterStatusFlag = "";                if (eqData.getAdd_time() == null) {                    waterStatusFlag = "0";                }                eqData.setWaterstatus(waterStatusFlag);                eqData.setFlowrate("0");                eqData.setSignalquality("好");                Long diffHour = (System.currentTimeMillis() - (eqData.getUpdate_time() == null ? 0L : Long.valueOf(eqData.getUpdate_time()))) / (1000 * 3600);                String flag = "";                if (diffHour < 24L) {                    flag = "2";                } else {                    flag = "1";                }                eqData.setCommunicationStatus(flag);                result.add(eqData);            }        } catch (NumberFormatException e) {            e.printStackTrace();        }        return result;    }    @Override    public Long queryOnlineNum(Map map) {        List<Map<String, Object>> onlineAndOfflineList = equipdataDao.queryOnlineAndOffLineNums(map);        return (Long) onlineAndOfflineList.get(0).get("onlineCount");    }    @Override    public void updateErrorData(Map<String, Object> equip) {        equipdataDao.updateErrorData(equip);    }    @Async    public void saveReadData(String data) {        String[] datas = data.split("  ");        Equipdata realData = new Equipdata();        String[] values = SpringSocketUtil.parse8082SocketData(datas[0]);        logger.info("values: " + values[0] + " , " + values[1] + " , " + values[2] + " , " + values[3]);        realData.setAddressCode(datas[1]);        realData.setNetCumulative(new BigDecimal(values[1]));        realData.setAreCumulative(new BigDecimal(values[2]));        realData.setFlowRate(new BigDecimal(values[3]).compareTo(new BigDecimal(10 ^ 7)) > 0 ? new BigDecimal(0.0) : new BigDecimal(values[3]));        realData.setAddTime(datas[2]);        try {            save(realData);            logger.info("save data.........." + realData.toString());        } catch (ServiceException e) {            logger.error(e.getMessage());            e.printStackTrace();        }        logger.info("Save equip data: " + realData.toString());    }    @Override    public Map<String, Object> queryStationCurrentData(String id) {        Map<String, Object> currentData = equipdataDao.getStationCurrentDataByDataId(id);        return currentData;    }    @Override    public void updateRealData(Map<String, Object> map) {        equipdataDao.updateRealData(map);    }    @Override    public Map<String, Object> getNewestDataByAddress(String addressCode) {        Map<String, Object> currentData = equipdataDao.getNewestDataByAddress(addressCode);        return currentData;    }    @Override    public void insertDataHistory(Map map) {        equipdataDao.insertDataHistory(map);    }    @Override    public void updateHistoryParentId(String addressCode) {        equipdataDao.updateHistoryParentId(addressCode);    }    /**     * dayAddressData     */    @Override    public List<Map<String, Object>> getHistoryDataEveryday(Map<String, Object> param) {        List<Map<String, Object>> datas = equipdataDao.getHistoryEveryday(param);        return datas;    }    /**     * dayAddressData     */    @Override    public Map<String, Object> getDayDataDayAddressData(List<Map<String, Object>> datas, String type) {        Map<String, Object> dayAddressData = new HashMap<>();        for (Map<String, Object> data : datas) {            Integer id = (Integer) data.get("equiptypeId");            String addTime = (String) data.get("addTime");            String timeType = DateUtils.getTime(addTime, type);            Double areCumulativeHis = (Double) data.get("areCumulativeHis");            dayAddressData.put(timeType + "_" + id, areCumulativeHis);        }        return dayAddressData;    }    @Override    public Map<String, Object> getDayDataAddressDayData(List<Map<String, Object>> datas) {        Map<String, Object> addressDayData = new HashMap<>();        for (Map<String, Object> data : datas) {            String addressCode = (String) data.get("addressCode");            String addTime = (String) data.get("addTime");            Double areCumulativeHis = (Double) data.get("areCumulativeHis ");            addressDayData.put(addressCode + "_" + addTime, areCumulativeHis);        }        return addressDayData;    }    /**     * map.put(addressCode , value)     */    public Map<String, Double> getSpecialDayData(Map map) {        Map<String, Double> specialDayMap = new HashMap<>(1000);        List<Map<String, Object>> datas = equipdataDao.getSpecialDayData(map);        Double v = 0.0;        for (Map<String, Object> item : datas) {            String addressCode = (String) item.get("addressCode");            v = (Double) item.get("areCumulative");            if (specialDayMap.containsKey(addressCode)) {                v = specialDayMap.get(addressCode) > v ? specialDayMap.get(addressCode) : v;            }            specialDayMap.put(addressCode, v);        }        return specialDayMap;    }    /**     * map.put(addressCode , value)     */    public Map<String, Double> getSpecialDayData2(String startDate, String endDate) {        Map<String, Double> specialDayMap = new HashMap<>(1000);        List<Map<String, Object>> datas = equipdataDao.getSpecialDayData2(startDate, endDate);        Double v = 0.0;        for (Map<String, Object> item : datas) {            String addressCode = (String) item.get("addressCode");            v = (Double) item.get("NetCumulative");            if (specialDayMap.containsKey(addressCode)) {                v = specialDayMap.get(addressCode) > v ? specialDayMap.get(addressCode) : v;            }            specialDayMap.put(addressCode, v);        }        return specialDayMap;    }    @Override    public List<Map<String, Object>> getHistoryDataSearch(Map map) {        List<Map<String, Object>> datas = equipdataDao.getHistorySearch(map);        return datas;    }    public List<ExportEquipData> formatExportData(List<CurrentEquipData> newestDataList) {        List<ExportEquipData> exportDatas = Lists.newArrayList();        ExportEquipData exportData = null;        for (CurrentEquipData currentData : newestDataList) {            exportData = new ExportEquipData();            int parentId = OrgUtils.getParentOrgId(currentData.getId());            exportData.setP2name(OrgUtils.getOrgName(OrgUtils.getParentOrgId(parentId)));            exportData.setP3name(OrgUtils.getOrgName(parentId));            exportData.setName(OrgUtils.getOrgName(currentData.getId()));            exportData.setAddresscode(currentData.getAddresscode());            exportData.setBengxing(currentData.getBengxing());            exportData.setKoujing(currentData.getKoujing());            exportData.setGonglv(currentData.getGonglv());            exportData.setNetcumulative(currentData.getNetcumulative());            exportData.setDate(currentData.getAdd_time());            exportDatas.add(exportData);        }        Collections.sort(exportDatas, new Comparator<ExportEquipData>() {            @Override            public int compare(ExportEquipData d1, ExportEquipData d2) {                return d1.getP2name().compareTo(d2.getP2name());            }        });        return exportDatas;    }}