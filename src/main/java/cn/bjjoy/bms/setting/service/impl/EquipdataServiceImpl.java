package cn.bjjoy.bms.setting.service.impl;import java.math.BigDecimal;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.atomic.AtomicInteger;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import cn.bjjoy.bms.setting.dao.BaseDao;import cn.bjjoy.bms.setting.dto.AnalysisDto;import cn.bjjoy.bms.setting.dto.CurrentEquipData;import cn.bjjoy.bms.setting.dto.OnlineOfflineNums;import cn.bjjoy.bms.setting.exception.ServiceException;import cn.bjjoy.bms.setting.persist.mapper.EquipdataDao;import cn.bjjoy.bms.setting.persist.model.Equipdata;import cn.bjjoy.bms.setting.service.EquipdataService;import cn.bjjoy.bms.util.DataUtils;import cn.bjjoy.bms.util.DateUtils;import cn.bjjoy.bms.util.SpringSocketUtil;/** * 类描述   :  * 创建人	：system * 创建时间 ：2018-09-13 23:02:18 * @version 1.0 */@SuppressWarnings("rawtypes")@Service@Transactionalpublic class EquipdataServiceImpl extends BaseServiceImpl<Equipdata> implements EquipdataService {		Logger logger = LoggerFactory.getLogger(EquipdataServiceImpl.class) ;		@Autowired	private EquipdataDao equipdataDao;	@Override	public BaseDao<Equipdata> getBaseDao() {		return equipdataDao;	}	public long getCurrentAccount(Map map){		return equipdataDao.getNewestDataCount(map) ;	}		@Override	public List<Map<String, Object>> queryOne(Map map) {		return equipdataDao.getNewestData(map);	}		@Override	public long getHistoryAccountNoPage(Map map){		if(map.containsKey("rows")){			map.remove("rows") ;		}		if(map.containsKey("page")){			map.remove("page") ;		}		return Long.valueOf(String.valueOf(equipdataDao.getHistoryEveryday(map).size())) ;	}		@Override	public List<Map<String, Object>> getHistoryNoPage(Map map) {		return equipdataDao.getDataNoPage(map);	}			public List<AnalysisDto> analysisesDto(Map map){		List<Map<String, Object>> mapAnalysis = equipdataDao.commonAnalysis(map);		return DataUtils.getDataArray(mapAnalysis, AnalysisDto.class);	}	AtomicInteger startIndex = new AtomicInteger();		@Override	public List<CurrentEquipData> setWifi(List<CurrentEquipData> equipList ,Map map) {		List<CurrentEquipData> result = new ArrayList<CurrentEquipData>();		try {			Integer page = 0;			if(map != null){				page = (Integer) map.get("page") ;				startIndex.set(page);			}			for(CurrentEquipData eqData : equipList){				eqData.setSeq(startIndex.incrementAndGet());				String waterStatusFlag = "" ;				if(eqData.getAdd_time() == null){					waterStatusFlag = "0" ;				}				eqData.setWaterstatus(waterStatusFlag);				eqData.setFlowrate("0");				Long diffHour = (System.currentTimeMillis() - (eqData.getUpdate_time() == null ? 0L : Long.valueOf(eqData.getUpdate_time()))) / (1000 * 3600) ;				String flag = "" ;				if(diffHour < 24L){					eqData.setSignalquality("好");					flag = "2" ;				}else{					eqData.setSignalquality("好");					flag = "1" ;				}				eqData.setCommunicationStatus(flag);				result.add(eqData);			}		} catch (NumberFormatException e) {			e.printStackTrace();		}		return result;	}	@Override	public List<OnlineOfflineNums> queryOnlineAndOffLineNums(Map map) {		List<OnlineOfflineNums> onlineOfflineNums = new ArrayList<>();		List<Map<String, Object>> onlineAndOfflineList = equipdataDao.queryOnlineAndOffLineNums(map);		Long onlineNum = 0L ;		Long offlineNum = 0L ;		for(Map<String, Object> onlineAndOfflineMap : onlineAndOfflineList){			if(onlineAndOfflineMap.containsKey("diffhour")){				Long keyDiffHour =  (Long)onlineAndOfflineMap.get("diffhour")  ;				if(keyDiffHour < 24L){					onlineNum += (Long)onlineAndOfflineMap.get("nums");				}else{					offlineNum += (Long)onlineAndOfflineMap.get("nums");				}			}else{				//add_time为空时，diffhour不包含在map里				offlineNum += (Long)onlineAndOfflineMap.get("nums");			}	    }		OnlineOfflineNums onNums = new OnlineOfflineNums();		onNums.setType("online");		onNums.setNum(onlineNum);		OnlineOfflineNums offNums = new OnlineOfflineNums();		offNums.setType("offline");		offNums.setNum(offlineNum);		onlineOfflineNums.add(onNums);		onlineOfflineNums.add(offNums);		return onlineOfflineNums;	}	@Override	public void updateErrorData(Map<String, Object> equip) {		equipdataDao.updateErrorData(equip) ;	}		@Async	public void saveReadData(String data){		String[] datas = data.split("  ") ;				Equipdata t = new Equipdata();		String[] values = SpringSocketUtil.parse8082SocketData(datas[0]);		logger.info("values: " + values[0] + " , " + values[1] + " , " + values[2] + " , " + values[3]);				t.setAddressCode(datas[1]);		t.setNetCumulative(new BigDecimal(values[1]));		t.setAreCumulative(new BigDecimal(values[2]));		t.setFlowRate(new BigDecimal(values[3]).compareTo(new BigDecimal(10 ^ 7)) > 0 ? new BigDecimal(0.0) : new BigDecimal(values[3]));		t.setAddTime(datas[2]);		try {			save(t);			logger.info("save data.........." + t.toString());		} catch (ServiceException e) {			logger.error(e.getMessage());			e.printStackTrace();		}		logger.info("Save equip data: " + t.toString());	}	@Override	public Map<String, Object> queryStationCurrentData(String id) {		Map<String, Object> currentData = equipdataDao.getStationCurrentDataByDataId(id) ;		return currentData;	}	@Override	public void updateRealData(Map<String, Object> map) {		equipdataDao.updateRealData(map) ;	}	@Override	public Map<String, Object> getNewestDataByAddress(String addressCode) {		Map<String, Object> currentData = equipdataDao.getNewestDataByAddress(addressCode) ;		return currentData;	}	@Override	public void insertDataHistory(Map map) {		equipdataDao.insertDataHistory(map);	}		/** dayAddressData */	@Override	public List<Map<String ,Object>> getHistoryDataEveryday(Map<String, Object> param) {		List<Map<String ,Object>> datas = equipdataDao.getHistoryEveryday(param) ;		return datas;	}		/** dayAddressData */	@Override	public Map<String, Object> getDayDataDayAddressData(List<Map<String ,Object>> datas , String type) {		Map<String, Object> dayAddressData = new HashMap<>();		for(Map<String,Object> data : datas){			Integer id = (Integer) data.get("equiptypeId") ;			String addTime = (String) data.get("addTime") ;			String timeType = DateUtils.getTime(addTime , type) ;			Double areCumulativeHis = (Double) data.get("areCumulativeHis") ;			dayAddressData.put( timeType + "_" + id , areCumulativeHis ) ;		}		return dayAddressData;	}	@Override	public Map<String, Object> getDayDataAddressDayData(List<Map<String ,Object>> datas) {		Map<String, Object> addressDayData = new HashMap<>();		for(Map<String,Object> data : datas){			String addressCode = (String) data.get("addressCode") ;			String addTime = (String) data.get("addTime") ;			Double areCumulativeHis = (Double) data.get("areCumulativeHis ") ;			addressDayData.put( addressCode + "_" + addTime, areCumulativeHis ) ;		}		return addressDayData ;	}	/** map.put(addressCode , value) */	public Map<String, Double> getSpecialDayData(Map map){		Map<String, Double> specialDayMap = new HashMap<>(1000);		List<Map<String, Object>> datas = equipdataDao.getSpecialDayData( map );		Double v = 0.0;		for(Map<String ,Object> item : datas){			String addressCode = (String) item.get("addressCode") ;			v = (Double) item.get("areCumulative") ;			if(specialDayMap.containsKey(addressCode)){				v = specialDayMap.get(addressCode) > v ? specialDayMap.get(addressCode) : v;			}			specialDayMap.put(addressCode, v) ;		}		return specialDayMap;	}	/** map.put(addressCode , value) */	public Map<String, Double> getSpecialDayData2(String startDate , String endDate){		Map<String, Double> specialDayMap = new HashMap<>(1000);		List<Map<String, Object>> datas = equipdataDao.getSpecialDayData2( startDate, endDate );		Double v = 0.0;		for(Map<String ,Object> item : datas){			String addressCode = (String) item.get("addressCode") ;			v = (Double) item.get("NetCumulative") ;			if(specialDayMap.containsKey(addressCode)){				v = specialDayMap.get(addressCode) > v ? specialDayMap.get(addressCode) : v;			}			specialDayMap.put(addressCode, v) ;		}		return specialDayMap;	}	}